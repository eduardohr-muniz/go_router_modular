# Dependency Injection

Manage your app's dependencies easily with built-in DI.

## What Is Dependency Injection?

Instead of creating objects directly, you register them and let the system provide them when needed.

```dart
// Instead of this
final service = MyService();

// Do this
i.addSingleton<MyService>(MyService.new);
final service = Modular.get<MyService>();
```

## Quick Start

### 1. Register Dependencies

```dart
class HomeModule extends Module {
  @override
 FutureBinds binds(Injector i) {
    i.addSingleton<HomeController>(HomeController.new);
    i.add<ApiService>(ApiService.new);
  }
}
```

### 2. Use Dependencies

```dart
class HomePage extends StatefulWidget {
  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  late final controller = context.read<HomeController>();
  //or
  final controller = Modular.get<HomeController>();

  @override
  Widget build(BuildContext context) {
    return Scaffold(/* ... */);
  }
}
```

## Dependency Types

### Singleton
One instance for the entire app:

```dart
i.addSingleton<DatabaseService>(DatabaseService.new);
```

### Factory
New instance every time:

```dart
i.add<ApiClient>(ApiClient.new);
```

### Lazy Singleton
Created only when first used:

```dart
i.addLazySingleton<HeavyService>(HeavyService.new);
```

## Async Dependencies

For dependencies that need async initialization:

```dart
class DatabaseModule extends Module {
  @override
  FutureOr<void> binds(Injector i) async {
    // Wait for database connection
    await Future.delayed(Duration(seconds: 1));
    
    i.addSingleton<DatabaseService>(DatabaseService.new);
  }
}
```

## Using Keys

Register multiple instances of the same type:

```dart
// Register with keys
i.addSingleton<ApiService>(ApiService.new, key: 'main');
i.addSingleton<ApiService>(ApiService.new, key: 'backup');

// Use with keys
final mainApi = Modular.get<ApiService>(key: 'main');
final backupApi = Modular.get<ApiService>(key: 'backup');
```

## Context Extension

Use the convenient `context.read()` extension:

```dart
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final service = context.read<MyService>();
    return Text(service.getData());
  }
}
```

## Real Example

```dart
class ProductsModule extends Module {
  @override
 FutureBinds binds(Injector i) {
    i.addSingleton<ProductsController>(ProductsController.new);
    i.add<ProductsRepository>(ProductsRepository.new);
    i.addLazySingleton<ApiService>(ApiService.new);
  }

  @override
  List<ModularRoute> get routes => [
    ChildRoute('/', child: (_, __) => ProductsPage()),
  ];
}

class ProductsPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final controller = context.read<ProductsController>();
    return Scaffold(
      body: ...,
    );
  }
}
```

## Best Practices

1. **Register in modules** - Keep dependencies organized
2. **Use singletons for services** - Database, API clients
3. **Use factories for data** - Models, DTOs
4. **Use keys when needed** - Multiple instances of same type
5. **Keep modules focused** - One module, one feature

---

**Need more details?** Check out the [Key System](#key-system) section below.