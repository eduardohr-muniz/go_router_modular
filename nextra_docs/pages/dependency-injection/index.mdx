# üíâ Dependency Injection

GoRouter Modular provides a powerful dependency injection system with automatic disposal to prevent memory leaks.

## üîß Basic Usage

### **Module Dependencies**

```dart
class HomeModule extends Module {
  @override
  void binds(Injector i) {
    i.addSingleton<HomeController>(() => HomeController());
    i.add<UserRepository>(() => UserRepository());
    i.addLazySingleton<ApiService>(() => ApiService());
  }

  @override
  List<ModularRoute> get routes => [
    ChildRoute('/', child: (context, state) => HomePage()),
  ];
}
```

### **Dependency Types**

#### **Singleton** - One instance for the entire module lifecycle
```dart
i.addSingleton<HomeController>(() => HomeController());
```

#### **Factory** - New instance every time
```dart
i.add<UserRepository>(() => UserRepository());
```

#### **Lazy Singleton** - Created only when first accessed
```dart
i.addLazySingleton<ApiService>(() => ApiService());
```

## üîç Retrieving Dependencies

### **Using Context**
```dart
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final controller = context.read<HomeController>();
    final repository = context.read<UserRepository>();
    
    return Scaffold(
      body: Text('Hello ${controller.userName}'),
    );
  }
}
```

### **Using Modular**
```dart
final controller = Modular.get<HomeController>();
final repository = Modular.get<UserRepository>();
```

### **Using Bind**
```dart
final controller = Bind.get<HomeController>();
final repository = Bind.get<UserRepository>();
```

### **Using Bind with Keys**
```dart
// Retrieve dependencies with specific keys
final localApi = Bind.get<ApiClient>(key: 'local');
final remoteApi = Bind.get<ApiClient>(key: 'remote');
final googleApi = Bind.get<ApiClient>(key: 'google');
```

## üîë Key System

The key system allows you to register multiple instances of the same type with different identifiers, enabling flexible dependency management for different environments or use cases.

### **Registering with Keys**
```dart
class ApiModule extends Module {
  @override
  void binds(Injector i) {
    // Register multiple ApiClient instances with different keys
    i.addLazySingleton<ApiClient>(
      () => ApiClient(baseUrl: 'http://localhost:8080'), 
      key: 'local'
    );
    i.addLazySingleton<ApiClient>(
      () => ApiClient(baseUrl: 'https://api.remote.com'), 
      key: 'remote'
    );
    i.addLazySingleton<ApiClient>(
      () => ApiClient(baseUrl: 'https://google.com'), 
      key: 'google'
    );
    
    // Register without key (default instance)
    i.addLazySingleton<ApiClient>(
      () => ApiClient(baseUrl: 'https://api.default.com')
    );
  }
}
```

### **Retrieving with Keys**
```dart
class ApiService {
  final ApiClient localApi;
  final ApiClient remoteApi;
  final ApiClient googleApi;
  final ApiClient defaultApi;
  
  ApiService() 
    : localApi = Bind.get<ApiClient>(key: 'local'),
      remoteApi = Bind.get<ApiClient>(key: 'remote'),
      googleApi = Bind.get<ApiClient>(key: 'google'),
      defaultApi = Bind.get<ApiClient>(); // No key = default instance
}
```

### **Dependency Injection with Keys**
```dart
class ApiModule extends Module {
  @override
  void binds(Injector i) {
    // Register Dio instances with keys
    i.addLazySingleton<Dio>(
      () => Dio(BaseOptions(baseUrl: 'http://localhost:8080')), 
      key: 'dio_local'
    );
    i.addLazySingleton<Dio>(
      () => Dio(BaseOptions(baseUrl: 'https://api.remote.com')), 
      key: 'dio_remote'
    );
    
    // Register service that depends on specific Dio instance
    i.add<ApiService>(
      () => ApiService(dio: i.get<Dio>(key: 'dio_remote'))
    );
  }
}
```

### **Key System Benefits**
- **Environment Management**: Different API endpoints for dev/staging/prod
- **Feature Flags**: Enable/disable features with different implementations
- **Testing**: Mock implementations with specific keys
- **Modularity**: Import modules that provide services with keys

## üîÑ Module Lifecycle

### **Initialization**
```dart
class AuthModule extends Module {
  @override
  void initState(Injector i) {
    // Initialize resources when module loads
    final authService = i.get<AuthService>();
    authService.initialize();
  }

  @override
  FutureOr<List<Bind<Object>>> binds() => [
    Bind.singleton<AuthService>((i) => AuthService()),
  ];
}
```

### **Disposal**
```dart
class AuthModule extends Module {
  @override
  void dispose() {
    // The dispose method is used when you want to execute an action when the module is disposed,
    // for example, stop listening to a stream or disconnect from a websocket.
  }
}
```

## ‚ö°Ô∏è Asynchronous Binds

You can use asynchronous binds to initialize dependencies that require async operations, such as fetching remote configuration or initializing plugins.

**Example: Remote Config (e.g., Firebase Remote Config)**
```dart
class RemoteConfigModule extends Module {
  @override
  FutureOr<List<Bind<Object>>> binds() async {
    // Fetch remote config asynchronously
    final remoteConfig = await RemoteConfig.instance.fetchAndActivate();
    return [
      Bind.singleton<Dio>(
        (i) => Dio(BaseOptions(baseUrl: remoteConfig.baseUrl)),
      ),
    ];
  }
}

class SharedPreferencesModule extends Module {
  @override
  FutureOr<List<Bind<Object>>> binds() async {
    // Initialize SharedPreferences asynchronously
    final prefs = await SharedPreferences.getInstance();
    return [
      Bind.singleton<SharedPreferences>((i) => prefs),
      Bind.singleton<LocalStorageService>((i) => LocalStorageService(prefs)),
    ];
  }
}
```

:::warning ‚ö†Ô∏è Important Note
In async `binds()` methods, avoid using `Modular.get<T>()` because the bind might not have been injected yet. Always use the `Injector` parameter or create dependencies directly.
:::

:::warning Asynchronous binds are strictly forbidden in the `AppModule`. Only use async binds in feature modules. The root `AppModule` must always use synchronous binds to ensure proper app initialization and avoid unpredictable behavior.
:::

## üéØ Advanced Patterns

### **Dependency with Parameters**
```dart
class UserModule extends Module {
  @override
  FutureOr<List<Bind<Object>>> binds() => [
    Bind.singleton<UserService>((i) => UserService(
      apiKey: 'your-api-key',
      baseUrl: 'https://api.example.com',
    )),
  ];
}
```

### **Dependent Dependencies**
```dart
class AppModule extends Module {
  @override
  FutureOr<List<Bind<Object>>> binds() => [
    Bind.singleton<ApiService>((i) => ApiService()),
    Bind.singleton<UserRepository>((i) => UserRepository(
      apiService: i.get<ApiService>(), // Inject dependency
    )),
  ];
}
```

### **Conditional Dependencies**
```dart
class AppModule extends Module {
  @override
  FutureOr<List<Bind<Object>>> binds() => [
    if (kDebugMode)
      Bind.singleton<Logger>((i) => DebugLogger())
    else
      Bind.singleton<Logger>((i) => ProductionLogger()),
  ];
}
```

## üõ°Ô∏è Memory Management

### **Automatic Disposal**
- Dependencies are automatically disposed when modules are unloaded
- Prevents memory leaks
- No manual cleanup required

## üìö Related Topics

- üèóÔ∏è [Project Structure](./project-structure) - Organize your modules
- üõ£Ô∏è [Routes](./routes) - Define module routes
- üé≠ [Event System](./event-system) - Module communication
